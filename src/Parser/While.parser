{
{-|
  Module      : Parser.While
  Description : A generated bottom-up LR parser for the WHILE language.
  Copyright   : 2014, Jonas Cleve
                2015, Tay Phuong Ho
                2016, Philip Schmiel
  License     : GPL-3
-}
module Parser.While (parse) where

import Interface.Token
import qualified Interface.AST as AST

}

%name       parse
%tokentype  { PosToken }

%tokens

id          { PosToken _ (Id $$) }
integer     { PosToken _ (DInt $$) }  -- $ modified
real        { PosToken _ (DDouble $$) }     -- $ added
bool        { PosToken _ (DBool $$) }
character   { PosToken _ (DChar $$) }
and         { PosToken _ (LogOp And) }
or          { PosToken _ (LogOp Or) }
not         { PosToken _  Not }
relop       { PosToken _ (RelOp $$) }
toClass     { PosToken _ ToClass}
'+'         { PosToken _ (MathOp Plus) }
'-'         { PosToken _ (MathOp Minus) }
'*'         { PosToken _ (MathOp Times) }
'/'         { PosToken _ (MathOp DivBy) }
mod         { PosToken _ (MathOp Mod) }
':='        { PosToken _  Assign }
':'         { PosToken _ NameSpace}
'.'         { PosToken _ Dot}
eof         { PosToken _  Eof }
read        { PosToken _  Read }
output      { PosToken _  Output }
return      { PosToken _  Return }       -- $ added
if          { PosToken _  If }
then        { PosToken _  Then }
else        { PosToken _  Else }
while       { PosToken _  While }
do          { PosToken _  Do }
int         { PosToken _ (Type TInt) }    -- $ added
double      { PosToken _ (Type TDouble) } -- $ added
char        { PosToken _ (Type TChar) }
ref         { PosToken _ (Type TRef)}
func        { PosToken _  Function }     -- $ added
labelspec   { PosToken _ LabelSpec}
'('         { PosToken _ (Token '(') }
')'         { PosToken _ (Token ')') }
'{'         { PosToken _ (Token '{') }
'}'         { PosToken _ (Token '}') }
'['         { PosToken _ (Token '[') }   -- $ added
']'         { PosToken _ (Token ']') }   -- $ added
';'         { PosToken _ (Token ';') }

%grammar

Program :: { AST.AST }
        : Cmds                          { $1 }

Cmds    :: { AST.Command }
        : Cmds ';' Instr                { AST.Sequence $1 $3 }
        | Instr                         { $1 }

Instr    :: { AST.Command }
        : Cmd                           { $1 }
        | Alloc                         { $1 }

Cmd     :: { AST.Command }
        : CmdO                          { $1 }
        | CmdC                          { $1 }
        |                               { AST.Skip }

CmdO    :: { AST.Command }
        : if Bexpr then Cmd             { AST.IfThen $2 $4 }
        | if Bexpr then CmdC else CmdO  { AST.IfThenElse $2 $4 $6 }
        | while Bexpr do CmdO           { AST.While $2 $4 }

CmdC    :: { AST.Command }
        : if Bexpr then CmdC else CmdC  { AST.IfThenElse $2 $4 $6 }
        | while Bexpr do CmdC           { AST.While $2 $4 }
        | read id                       { AST.Read $2 }
        | output Expr                   { AST.Output $2 }
        | return Expr                   { AST.Return $2 }
        | id ':=' Expr                  { AST.Assign $1 $3 }
        | id '[' Expr ']' ':=' Expr     { AST.ToArray $1 $3 $6 }
        | '{' Cmds '}'                  { AST.Environment $2 }
        | func Decl '(' Decls ')' '{' Cmds '}'  { AST.Function $2 $4 $7 }
        | labelspec id '{' Decls '}'          { AST.LabelEnvironment $2 $4 }

Expr    :: { AST.Expression }
        : Expr '+' Term                 { AST.Calculation Plus $1 $3 }
        | Expr '-' Term                 { AST.Calculation Minus $1 $3 }
        | Term                          { $1 }

Term    :: { AST.Expression }
        : Term '*' Factor               { AST.Calculation Times $1 $3 }
        | Term '/' Factor               { AST.Calculation DivBy $1 $3 }
        | Term mod Factor               { AST.Calculation Mod $1 $3 }
        | Term '.' Factor               { AST.SolveReference $1 $3}
        | Factor                        { $1 }

Factor  :: { AST.Expression }
        : '(' Expr ')'                  { $2 }
        | '-' Factor                    { AST.Negate $2 }
        | id                            { AST.Identifier $1 }
        | id '[' Expr ']'               { AST.FromArray $1 $3 }
        | id '(' Params ')'             { AST.Func $1 $3 }
        | id ':' id '(' ')'             { AST.Func ($1++":"++$3) (AST.Parameter AST.Void) }
        | id ':' id '(' Params ')'      { AST.Func ($1++":"++$3) $5}
        | id ':' id                     { AST.Reference $1 $3}
        | ':' id                        { AST.Reference "default" $2}
        | toClass id                    { AST.ToClass $2}
        | integer                       { AST.Integer $1 }
        | real                          { AST.Double $1 }
        | character                     { AST.Character $1}

Bexpr   :: { AST.BoolExpression }
        : Bexpr or Bterm                { AST.LogOp Or $1 $3 }
        | Bterm                         { $1 }

Bterm   :: { AST.BoolExpression }
        : Bterm and Bfactor             { AST.LogOp And $1 $3 }
        | Bfactor                       { $1 }

Bfactor :: { AST.BoolExpression }
        : '(' Bexpr ')'                 { $2 }
        | not Bfactor                   { AST.Not $2 }
        | Expr relop Expr               { AST.Comparison $2 $1 $3 }
        | bool                          { AST.Boolean $1 }
        | eof                           { AST.Eof }

Primitives :: { AST.Command }
        : Type id                        { AST.Declaration $1 $2 }

Alloc    :: { AST.Command }
        : Primitives                    { $1 }
        | Type '[' Expr ']' id           { AST.ArrayAlloc $1 $3 $5 }

Decl    :: { AST.Command }
        : Primitives                    { $1 }
        | Type '[' ']' id                { AST.ArrayDecl $1 $4 }

Decls   :: { AST.Command }
        : Decls ';' Decl                { AST.Sequence $1 $3 }
        | Decl                          { $1 }

Params  :: { AST.Expression }
        : Params ';' Param              { AST.Parameters $1 $3 }
        | Param                         { $1 }

Param  :: { AST.Expression }
        : Expr                          { AST.Parameter $1 }

Types :: { Type }
       : Types ';' Type                 { TypeSequence $1 $3 }
       | Type                           { $1 }

Type :: { Type }
      : int                             { TInt }
      | double                          { TDouble }
      | char                            { TChar }
      | ref                             { TRef }
      | Type '(' Types ')'         { TFunction $1 $3 }
